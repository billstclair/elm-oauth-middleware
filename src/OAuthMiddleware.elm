----------------------------------------------------------------------
--
-- OAuthMiddleware.elm
-- Client side of an OAuth Authorization Code Grant Flow
-- Copyright (c) 2017 Bill St. Clair <billstclair@gmail.com>
-- Some rights reserved.
-- Distributed under the MIT License
-- See LICENSE.txt
--
----------------------------------------------------------------------


module OAuthMiddleware
    exposing
        ( Authorization
        , RedirectState
        , authorize
        , decodeRedirectState
        , decodeResponseToken
        , encodeRedirectState
        , encodeResponseToken
        , responseTokenQuery
        , responseTokenQueryError
        )

{-| Client side of OAuth Authorization Code Grant Flow.


# Types

@docs Authorization, RedirectState


# Client-side functions

@docs authorize


# Query parameters for return URL from redirect server

@docs responseTokenQuery, responseTokenQueryError


# Encode/Decode state for passing over the wire.

@docs encodeRedirectState, decodeRedirectState
@docs encodeResponseToken, decodeResponseToken

-}

import Json.Decode as JD exposing (Decoder)
import Json.Encode as JE exposing (Value)
import OAuth
import OAuth.AuthorizationCode
import OAuthMiddleware.EncodeDecode as ED
import Task exposing (Task)


{-| Configuration for sending a request to the authorization server.

`authorizationUri` and `tokenUri` are provided by the OAuth authentication service.

`authorize` sends a request to `authorizationUri`, encoding the other parameters into the `state` sent there. The `redirectUri` server, implemented by the `server` directory of this package, uses the `tokenUri` as a key into its table containing valid values for `redirectBackUri` and the client secret that will be sent to the `tokenUri`.

`clientId`, `redirectUri`, `scope`, and `state` are all standard parts of the OAuth protocol, except `state` is optional here, and encoded so it comes back just as it went out.

`clientId` is assigned by the OAuth resource. It also provides a list of possible `scope` values. You can use any subset of those.

`redirectUri` is sent to the OAuth authorization web server. If the user successfullly logs in, an authorization code will be sent there as a Uri query parameter.

`state` is any string you'd like. It is passed to the authorization web server, which passes it to the `redirectUri`, and it is passed back to your application via the `redirectBackUri` or a request generated by `getToken`.

`redirectBackUri` is a Uri to redirect to AFTER the `redirectUri` exchanges the received code for an access token. It will resume your Elm application, this time with an access token in its hand.

-}
type alias Authorization =
    { authorizationUri : String
    , tokenUri : String
    , clientId : String
    , redirectUri : String
    , scope : List String
    , state : Maybe String
    , redirectBackUri : String
    }


{-| Send an authorization request.

This will cause the authorization server to ask the user to login. If successful, it will send the received code and `Authorization.state` to the `Authorization.redirectUri` for generation of a token to send back to the `Authorization.redirectBackUri`. Your code at that Uri will receive an encoded `OAuth.ResponseToken` on the `responseTokenQuery` parameter, or an error string on the `responseTokenQueryError` parameter. Use `decodeResponseToken` to turn the `responseTokenQuery` string into an `OAuth.ResponseToken`, which you can use to do authenticated requests, just as if you had called `OAuth.AuthorizationCode.authenticate` yourself, but hiding the client secret on the redirect server.

-}
authorize : Authorization -> Cmd msg
authorize { authorizationUri, tokenUri, clientId, redirectUri, redirectBackUri, scope, state } =
    OAuth.AuthorizationCode.authorize
        { clientId = clientId
        , redirectUri = redirectUri
        , responseType = OAuth.Code
        , scope = scope
        , state =
            Just <|
                encodeRedirectState
                    { clientId = clientId
                    , tokenUri = tokenUri
                    , redirectUri = redirectUri
                    , scope = scope
                    , redirectBackUri = redirectBackUri
                    , state = state
                    }
        , url = authorizationUri
        }


{-| The state sent to the `redirectUri`.
-}
type alias RedirectState =
    ED.RedirectState


{-| Decode the state encoded by `encodeRedirectState`.
-}
decodeRedirectState : String -> Result String RedirectState
decodeRedirectState json =
    JD.decodeString ED.redirectStateDecoder json


{-| Encode the redirectBackUri and user state for the authorization server.
-}
encodeRedirectState : RedirectState -> String
encodeRedirectState redirectState =
    JE.encode 0 <|
        ED.redirectStateEncoder redirectState


{-| The URL query parameter for a ResponseToken returned from the redirect server.
-}
responseTokenQuery : String
responseTokenQuery =
    "response-token"


{-| The URL query parameter for a ResponseToken error returned from the redirect server.
-}
responseTokenQueryError : String
responseTokenQueryError =
    "response-token-error"


{-| Decode the `ResponseToken` that is sent back to the `redirectUri`
from the redirect server.
-}
decodeResponseToken : String -> Result String OAuth.ResponseToken
decodeResponseToken json =
    JD.decodeString ED.responseTokenDecoder json


{-| Encode the `ResponseToken` that is received by the redirect server
from its call to `OAuth.AuthorizationCode.authenticate`.
-}
encodeResponseToken : OAuth.ResponseToken -> String
encodeResponseToken responseToken =
    JE.encode 0 <|
        ED.responseTokenEncoder responseToken
