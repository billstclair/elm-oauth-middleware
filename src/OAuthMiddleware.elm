----------------------------------------------------------------------
--
-- OAuthMiddleware.elm
-- Client side of an OAuth Authorization Code Grant Flow
-- Copyright (c) 2017 Bill St. Clair <billstclair@gmail.com>
-- Some rights reserved.
-- Distributed under the MIT License
-- See LICENSE.txt
--
----------------------------------------------------------------------


module OAuthMiddleware
    exposing
        ( Authorization
        , RedirectState
        , TokenState
        , authorize
        , decodeRedirectState
        , decodeToken
        , encodeRedirectState
        , encodeToken
        )

{-| Client side of OAuth Authorization Code Grant Flow.


# Types

@docs Authorization, RedirectState, TokenState


# Client-side functions

@docs authorize, decodeToken


# Encode/Decode state for passing over the wire.

@docs encodeToken, decodeRedirectState, encodeRedirectState

-}

import Json.Decode as JD exposing (Decoder)
import Json.Encode as JE exposing (Value)
import OAuth
import OAuth.AuthorizationCode
import Task exposing (Task)


{-| Configuration for sending a request to the authorization server.

`clientId`, `redirectUri`, `scope`, and `state` are all standard parts of the OAuth protocol, except `state` is optional here, and encoded so it comes back just as it went out.

`clientId` is assigned by the OAuth resource. It also provides a list of possible `scope` values. You can use any subset of those.

`redirectUri` is sent to the OAuth authorization web server. If the user successfullly logs in, an authorization code will be sent there as a Uri query parameter.

`state` is any string you'd like. It is passed to the authorization web server, which passes it to the `redirectUri`, and it is passed back to your application via the `redirectBackUri` or a request generated by `getToken`.

`redirectBackUri` is a Uri to redirect to AFTER the `redirectUri` exchanges the received code for an access token. If it is `Nothing`, no redirect will be done.

`tokenKey` is a key that the client can use to explicitly ask the redirectUri for the token. If it is `Nothing`, the token will be forgotten once it is sent to the `redirectBackUri`. Otherwise, it will be held onto until requested, or a timeout, which is configurable in the server code.

-}
type alias Authorization =
    { clientId : String
    , redirectUri : String
    , scope : List String
    , state : Maybe String
    , url : String
    , redirectBackUri : Maybe String
    , tokenKey : Maybe String
    }


{-| Send an authorization request.

This will cause the authorization server to ask the user to login. If successful, it will send the received code and `Authorization.state` to the `Authorization.redirectUri` for generation of a token to send back to the `Authorization.redirectBackUri`. Your code at that Uri will pass the encoded token and state to `receiveToken`, for unpackaging.

-}
authorize : Authorization -> Cmd msg
authorize { clientId, redirectUri, redirectBackUri, tokenKey, scope, state, url } =
    OAuth.AuthorizationCode.authorize
        { clientId = clientId
        , redirectUri = redirectUri
        , responseType = OAuth.Code
        , scope = scope
        , state =
            Just <|
                encodeRedirectState
                    { redirectBackUri = redirectBackUri
                    , tokenKey = tokenKey
                    , state = state
                    }
        , url = url
        }


{-| Get the token from the `redirectUri` when you can't handle a redirectBackUri.

This happens when your client is a device rather than a web browser.

You can pass the same `Authorization` here that you passed to `authorize`,
but only the `redirectUri` and the `tokenKey` are used here.

Returns a `Task` that does an HTTP request to the `redirectUri`.

This function is not yet implemented. The Task it returns will always error.

-}
getToken : Authorization -> Task String ( String, Maybe String )
getToken { redirectUri, tokenKey } =
    -- TODO
    Task.fail "getToken is not yet implemented."


{-| The token and user string returned by the `redirectUri` server.
-}
type alias TokenState =
    { token : String
    , state : Maybe String
    }


{-| Decode the state sent to the authorization server.

When your code is invoked at the `Authorization.redirectBackUri` passed to `authorize`, you call `receiveToken` with the `state` you receive in the URL, and this function decodes it into an authorization token and the `Authorization.state` you passed to `authorize`.

The server uses `encodeToken` to create this string.

-}
decodeToken : String -> Result String TokenState
decodeToken json =
    JD.decodeString tokenStateDecoder json


{-| Encode the token and user state for the redirectBackUri.
-}
encodeToken : TokenState -> String
encodeToken tokenState =
    JE.encode 0 <|
        tokenStateEncoder tokenState


{-| The state sent to the `redirectUri`.
-}
type alias RedirectState =
    { redirectBackUri : Maybe String
    , tokenKey : Maybe String
    , state : Maybe String
    }


{-| Decode the state encoded by `encodeRedirectState`.
-}
decodeRedirectState : String -> Result String RedirectState
decodeRedirectState json =
    JD.decodeString redirectStateDecoder json


{-| Encode the redirectBackUri and user state for the authorization server.
-}
encodeRedirectState : RedirectState -> String
encodeRedirectState redirectState =
    JE.encode 0 <|
        redirectStateEncoder redirectState



---
--- Internals
---


redirectStateDecoder : Decoder RedirectState
redirectStateDecoder =
    JD.map3 RedirectState
        (JD.field "redirectBackUri" <| JD.nullable JD.string)
        (JD.field "tokenKey" <| JD.nullable JD.string)
        (JD.field "state" <| JD.nullable JD.string)


nullableStringEncoder : Maybe String -> Value
nullableStringEncoder string =
    case string of
        Nothing ->
            JE.null

        Just s ->
            JE.string s


redirectStateEncoder : RedirectState -> Value
redirectStateEncoder state =
    JE.object
        [ ( "redirectBackUri", nullableStringEncoder state.redirectBackUri )
        , ( "tokenKey", nullableStringEncoder state.tokenKey )
        , ( "state", nullableStringEncoder state.state )
        ]


tokenStateDecoder : Decoder TokenState
tokenStateDecoder =
    JD.map2 TokenState
        (JD.field "token" <| JD.string)
        (JD.field "state" <| JD.nullable JD.string)


tokenStateEncoder : TokenState -> Value
tokenStateEncoder state =
    JE.object
        [ ( "token", JE.string state.token )
        , ( "state"
          , case state.state of
                Nothing ->
                    JE.null

                Just s ->
                    JE.string s
          )
        ]
