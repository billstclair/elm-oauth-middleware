----------------------------------------------------------------------
--
-- OAuthMiddleware.elm
-- Client side of an OAuth Authorization Code Grant Flow
-- Copyright (c) 2017 Bill St. Clair <billstclair@gmail.com>
-- Some rights reserved.
-- Distributed under the MIT License
-- See LICENSE.txt
--
----------------------------------------------------------------------


module OAuthMiddleware
    exposing
        ( Authorization
        , RedirectState
        , authorize
        , decodeRedirectState
        , decodeResponseToken
        , encodeRedirectState
        , encodeResponseToken
        )

{-| Client side of OAuth Authorization Code Grant Flow.


# Types

@docs Authorization, RedirectState


# Client-side functions

@docs authorize


# Encode/Decode state for passing over the wire.

@docs encodeRedirectState, decodeRedirectState
@docs encodeResponseToken, decodeResponseToken

-}

import Json.Decode as JD exposing (Decoder)
import Json.Encode as JE exposing (Value)
import OAuth
import OAuth.AuthorizationCode
import Task exposing (Task)


{-| Configuration for sending a request to the authorization server.

`clientId`, `redirectUri`, `scope`, and `state` are all standard parts of the OAuth protocol, except `state` is optional here, and encoded so it comes back just as it went out.

`clientId` is assigned by the OAuth resource. It also provides a list of possible `scope` values. You can use any subset of those.

`redirectUri` is sent to the OAuth authorization web server. If the user successfullly logs in, an authorization code will be sent there as a Uri query parameter.

`state` is any string you'd like. It is passed to the authorization web server, which passes it to the `redirectUri`, and it is passed back to your application via the `redirectBackUri` or a request generated by `getToken`.

`redirectBackUri` is a Uri to redirect to AFTER the `redirectUri` exchanges the received code for an access token. If it is `Nothing`, no redirect will be done.

-}
type alias Authorization =
    { clientId : String
    , redirectUri : String
    , scope : List String
    , state : Maybe String
    , url : String
    , redirectBackUri : String
    }


{-| Send an authorization request.

This will cause the authorization server to ask the user to login. If successful, it will send the received code and `Authorization.state` to the `Authorization.redirectUri` for generation of a token to send back to the `Authorization.redirectBackUri`. Your code at that Uri will pass the encoded token and state to `receiveToken`, for unpackaging.

-}
authorize : Authorization -> Cmd msg
authorize { clientId, redirectUri, redirectBackUri, scope, state, url } =
    OAuth.AuthorizationCode.authorize
        { clientId = clientId
        , redirectUri = redirectUri
        , responseType = OAuth.Code
        , scope = scope
        , state =
            Just <|
                encodeRedirectState
                    { redirectUri = redirectUri
                    , scope = scope
                    , redirectBackUri = redirectBackUri
                    , state = state
                    }
        , url = url
        }


{-| The state sent to the `redirectUri`.
-}
type alias RedirectState =
    { redirectUri : String
    , scope : List String
    , redirectBackUri : String
    , state : Maybe String
    }


{-| Decode the state encoded by `encodeRedirectState`.
-}
decodeRedirectState : String -> Result String RedirectState
decodeRedirectState json =
    JD.decodeString redirectStateDecoder json


{-| Encode the redirectBackUri and user state for the authorization server.
-}
encodeRedirectState : RedirectState -> String
encodeRedirectState redirectState =
    JE.encode 0 <|
        redirectStateEncoder redirectState


{-| Decode the `ResponseToken` that is sent back to the `redirectUri`
from the redirect server.
-}
decodeResponseToken : String -> Result String OAuth.ResponseToken
decodeResponseToken json =
    JD.decodeString responseTokenDecoder json


{-| Encode the `ResponseToken` that is received by the redirect server
from its call to `OAuth.AuthorizationCode.authenticate`.
-}
encodeResponseToken : OAuth.ResponseToken -> String
encodeResponseToken responseToken =
    JE.encode 0 <|
        responseTokenEncoder responseToken



---
--- Internals
---


redirectStateDecoder : Decoder RedirectState
redirectStateDecoder =
    JD.map4 RedirectState
        (JD.field "redirectUri" JD.string)
        (JD.field "scope" <| JD.list JD.string)
        (JD.field "redirectBackUri" JD.string)
        (JD.field "state" <| JD.nullable JD.string)


nullableStringEncoder : Maybe String -> Value
nullableStringEncoder string =
    case string of
        Nothing ->
            JE.null

        Just s ->
            JE.string s


redirectStateEncoder : RedirectState -> Value
redirectStateEncoder state =
    JE.object
        [ ( "redirectUri", JE.string state.redirectUri )
        , ( "scope", JE.list <| List.map JE.string state.scope )
        , ( "redirectBackUri", JE.string state.redirectBackUri )
        , ( "state", nullableStringEncoder state.state )
        ]


tokenEncoderFields : OAuth.Token -> List ( String, Value )
tokenEncoderFields token =
    [ ( "access_token"
      , case token of
            OAuth.Bearer s ->
                JE.string s
      )
    , ( "token_type", JE.string "bearer" )
    ]


responseTokenEncoder : OAuth.ResponseToken -> Value
responseTokenEncoder responseToken =
    List.concat
        [ tokenEncoderFields responseToken.token
        , case responseToken.expiresIn of
            Nothing ->
                []

            Just ex ->
                [ ( "expires_in", JE.int ex ) ]
        , case responseToken.refreshToken of
            Nothing ->
                []

            Just token ->
                tokenEncoderFields token
        , case responseToken.scope of
            [] ->
                []

            scope ->
                [ ( "scope", JE.list <| List.map JE.string scope ) ]
        , case responseToken.state of
            Nothing ->
                []

            Just state ->
                [ ( "state", JE.string state ) ]
        ]
        |> JE.object



---
--- From the truqu/elm-oauth2 Internal module.
--- Not exported, so I had to copy it.
---


responseTokenDecoder : Decoder OAuth.ResponseToken
responseTokenDecoder =
    JD.oneOf
        [ JD.map5
            (\token expiresIn refreshToken scope state ->
                { token = token
                , expiresIn = expiresIn
                , refreshToken = refreshToken
                , scope = Maybe.withDefault [] scope
                , state = state
                }
            )
            accessTokenDecoder
            (JD.maybe <| JD.field "expires_in" JD.int)
            refreshTokenDecoder
            (JD.maybe <| JD.field "scope" (JD.list JD.string))
            (JD.maybe <| JD.field "state" JD.string)
        ]


accessTokenDecoder : JD.Decoder OAuth.Token
accessTokenDecoder =
    let
        mtoken =
            JD.map2 makeToken
                (JD.field "access_token" JD.string |> JD.map Just)
                (JD.field "token_type" JD.string)

        failUnless =
            Maybe.map JD.succeed >> Maybe.withDefault (JD.fail "can't decode token")
    in
    JD.andThen failUnless mtoken


refreshTokenDecoder : JD.Decoder (Maybe OAuth.Token)
refreshTokenDecoder =
    JD.map2 makeToken
        (JD.maybe <| JD.field "refresh_token" JD.string)
        (JD.field "token_type" JD.string)


makeToken : Maybe String -> String -> Maybe OAuth.Token
makeToken mtoken tokenType =
    case ( mtoken, String.toLower tokenType ) of
        ( Just token, "bearer" ) ->
            Just <| OAuth.Bearer token

        _ ->
            Nothing
